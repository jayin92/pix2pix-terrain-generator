#pragma kernel Rain
#pragma kernel CalculateFlux
#pragma kernel Flow
#pragma kernel Erode
#pragma kernel Transport
#pragma kernel Deposit

#define gs 16
#define gxb(x,y) b[x+1,y]-b[x,y]

RWStructuredBuffer<float> b;
RWStructuredBuffer<float> b1;
RWStructuredBuffer<float> d,d1;
RWStructuredBuffer<float> s,s1;
RWStructuredBuffer<float4> f;//rltb
int w = 256, h = 256;
float KRain = 1, KCapacity = 1, A = 1, Kdmax = 1, KS = 1, KD = 1, RMin = 0.5, KH = 1, KEvaporation = 0.1, KMove = 10, drag = 0.1, maxV = 0.01, deltaT = 0.02;
[numthreads(gs, gs, 1)]
void Rain (uint3 id : SV_DispatchThreadID)
{
    d[id.x + id.y * w] *= (1.0 - KEvaporation);
    d[id.x+id.y*w] += KRain * deltaT;
}
[numthreads(gs, gs, 1)]
void CalculateFlux(uint3 id : SV_DispatchThreadID)
{
    int i = id.x + id.y * w;

    f[i][2] *= (1 - drag);
    f[i][3] *= (1 - drag);
    f[i][0] *= (1 - drag);
    f[i][1] *= (1 - drag);

    
    float grad = b[i] + d[i] - b[i + 1] - d[i + 1];
    f[i][0] = max(0, f[i][0] + deltaT * A * grad / (grad*grad+1));
    grad = b[i] + d[i] - b[i - 1] - d[i - 1];
    f[i][1] = max(0, f[i][1] + deltaT * A * grad / (grad * grad + 1));
    grad = b[i] + d[i] - b[i +w] - d[i +w];
    f[i][2] = max(0, f[i][2] + deltaT * A * grad / (grad * grad + 1));
    grad = b[i] + d[i] - b[i -w] - d[i -w];
    f[i][3]= max(0, f[i][3] + deltaT * A * grad / (grad * grad + 1));
    
    float k=1; 
    if ((f[i][0] + f[i][1] + f[i][2] + f[i][3]) > 0.0001) k= min(1, d[i] / (f[i][0] + f[i][1] + f[i][2] + f[i][3]) / deltaT);
    f[i][0] *= k;
    f[i][1] *= k;
    f[i][2] *= k;
    f[i][3] *= k;
    s1[i] = s[i];
    d1[i] = d[i];
}
[numthreads(gs, gs, 1)]
void Transport(uint3 id : SV_DispatchThreadID)
{
    
    int i = id.x + id.y * w;
    float a = s1[i] * f[i][0] / (d1[i] + 0.00001) * deltaT;
    s[i] -= a;
    d[i] -= a;
    s[i + 1] += a;
    d[i + 1] += a;
    a = s1[i] * f[i][1] / (d1[i] + 0.00001) * deltaT;
    s[i] -= a;
    d[i] -= a;
    s[i - 1] += a;
    d[i - 1] += a;
    a = s1[i] * f[i][2] / (d1[i] + 0.00001) * deltaT;
    s[i] -= a;
    d[i] -= a;
    s[i + w] += a;
    d[i + w] += a;
    a = s1[i] * f[i][3] / (d1[i] + 0.00001) * deltaT ;
    s[i] -= a;
    d[i] -= a;
    s[i - w] += a;
    d[i - w] += a;
}

[numthreads(gs, gs, 1)]
void Flow(uint3 id : SV_DispatchThreadID)
{
    int i = id.x + id.y * w;
    
    d[i] -= (f[i][0] + f[i][1] + f[i][2] + f[i][3])*deltaT;
    if (id.x > 0)
    d[i] += f[i-1][0] * deltaT;
    if (id.x <w-1)
    d[i] += f[i+1][1] * deltaT;
    if (id.y > 0)
    d[i] += f[i - w][2] *  deltaT;
    if (id.y<h-1)
    d[i] += f[i+w][3] * deltaT;
    b1[i] = b[i];
    d1[i] = d[i];
   
}


[numthreads(gs, gs, 1)]
void Erode(uint3 id : SV_DispatchThreadID )
{ 
    int i = id.x + id.y * w;
    float db;
    float dd;
    float n;
    
    if ((id.x != ( w - 1))  && (id.x != 0))
    {
        db = b1[i + 1] - b1[i];
        dd = d1[i + 1] - d1[i];
        n = max(0, (f[i][0] - f[i + 1][1]) * (f[i][0] - f[i + 1][1]) * max(0, 1 - (d1[i] + d1[i + 1 ])*KH) * deltaT * KS);
        //int i2 = i + (f[i][0] - f[i + 1][1] > 0);
        int i2 = i + (b1[i] - b1[i + 1] < 0);
        b[i2] -= n;
        d[i2] += n;
        s[i2] += n;
    }
     
    db = b1[i + w] - b1[i];
    dd = d1[i + w] - d1[i];
    n = max(0, (f[i][2] - f[i + w][3]) * (f[i][2] - f[i + w][3])  * max(0, 1 - (d1[i] + d1[i + w]) * KH)*deltaT * KS);
   // int i2 = i + w* (f[i][0] - f[i + w][1] > 0);
    int i2 = i + w*(b1[i] - b1[i + w] < 0);
    b[i2] -= n ;
    d[i2] += n ;
    s[i2] += n;
    
}


[numthreads(gs, gs, 1)] 
void Deposit(uint3 id : SV_DispatchThreadID)
{
    int i = id.x + id.y * w;
    float dis = min(KD * s[i], s[i]);
    
    
    s[i] -= dis;
    d[i] -= dis;
    b[i] += dis;
    if (s[i] > d[i])
    {
        dis = s[i] - d[i];
        s[i] -= dis;
        d[i] -= dis; 
        b[i] += dis;
    }

}